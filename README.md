# mini-readability
need find articles in html page

## Задача
Вычленить из веб-страницы только полезную информацию, отбросив весь «мусор» (навигацию, рекламу и тд).
Найденный текст надо отформатировать и сохранить на диск в файл
Так же все ссылки надо обработать в соответствии с правилом в файле "Задача C++|Python – Mini readability"

## Описание алгоритма
Приложение вызывается из консоли с передачей одного параметра - ссылки на страницу, которую надо обработать.
Для запуска нужен установленный Python 3.7
Класс MiniReadability содержит методы для поиска необходимой информации, форматирования выходного текста и его передачи для последующей обработки.
Обработка текста заключается в его сохранении на диск в папку, структура которой описана в задании "Задача C++|Python – Mini readability"

Чаще всего полезная информация содержится в тэге "<p>", он основной для поиска, так же есть дополнительные "<h1> <li>"
Так как на разных сайтах верстка страницы происходит по-разному и тэги с текстом используются и в других частях, то быстрее всего обрабатывать конкретный сайт по заданным правилам.
Правила задают мета тэги (meta_tags), например <div class=...>, <article>, и тэги с самим текстом: "<p> <h1> <li>" ...
Сначала находятся все мета тэги, затем в них все тэги с текстом.
Если для сайта нет заданных правил, то ищется мета тэг, в котором содержится больше всего текста
И с высокой вероятностью в таком мета тэге будет необходимая информация.

Имеется файл templates.json, в котором хранятся шаблоны обработки для конкретного сайта
Шаблоны хранят мета тэги-контейнеры, в которых содержаться тэги с текстом
Мета тэги (meta_tags) обычно: <div class=...>, <article>
Основные тэги (text_tags) для хранения полезной информации: <p>, <h1>, <h2>, <li>
Так же можно удалять из поиска заведомо ненужные тэги, например тэг <footer>

Обобщенный алгоритм
1. Загрузка сырого кода страницы по урлу
2. Построение Dom-дерева с помощью библиотеки BeautifulSoup v4
3. Определение по урлу имени сайта (host name)
4.1 Если для конкретного сайта есть шаблон обработки, то выполняется поиск узлов по шаблону
4.2 Если шаблона нет, то находятся все узлы в которых есть текст (text_tags)
5. Шаг 4 дает список всех тэгов с текстом (text_tags)
6. Из тэгов извлекается текст, форматирунтся, ссылки заменяются по правилам замены
7. По урлу формируется имя файла и имя директории по заданным правилам
8. Найденный текст сохраняется в файл
9. Радость и успех

4.1 Поиск текстовых тэгов (text_tags) для сайта без шаблона
4.1.1 Сначала находятся все ноды (nodes) с текстовыми тэгами по умолчани: "<p> <h1> <h2>" и помещаются в список text_node_list
4.1.2 Заполнение словаря всех родителей ({parent: text_length}) первого порядка для всех в списке text_node_list, каждому родителю прибавляе длина текста, которую он сожержит
4.1.3 Среди всех родителей надодится узел с самым большим количеством текста
4.1.4 В самом "объемного" узле находятся все узлы с текстовыми тэгами (text_tags) и возвращается их список
  

## Результаты
Поиск текста для сайта без шаблона не на всех сайтах работает точно, так как очень разные структуры верстки используются

https://lenta.ru/news/2018/08/13/ecological_tax/ - поиск всей статьи успешно (алгоритм с шаблоном), без шаблона не находится заголовок
"http://www.vesti.ru/doc.html?id=2699112&cid=9" - поиск всей статьи успешно (алгоритм с шаблоном), без шаблона не находится заголовок
https://tensor.ru   - найден текст из раздела "О компании" без заголовка (алгоритм без шаблона)
https://tensor.ru/news/1371   - найдет текст новости, но без заголовка (алгоритм без шаблона)
https://cheremuha.com/2018/08/20/ruk-proverka-ksp.html - найдет текст новости, но без заголовка (алгоритм без шаблона)

## Развитие программы
1. Улучшение общего алгоритма поиска текста (без шаблона): искать текст не в тэгах <p> <h1> <li>, а искать сам текст вне зависимости от тэгов. На некоторых сайтах (например, https://habr.com/post/198982/) текст содержится в теле <div>. Для этого надо определить правила отличия текста от кода страницы (например, наличие знаков препинания (например, '.')), затем сравнение блоков текста и оценка их на соответствие текст это или нет.
2. Добавить шаблоны форматирования текста:
2.1 Настройка выделение заголовков другим размером шрифта
2.2 Настройка отбивки параграфов
2.3 Настройка ширины текста
3. Добавить шаблоны на замену ссылок и списков <li> <ul>
4. Добавить поиск медиа контента: изображений, видео, твитов в теле статьи и их сохранение или ссылку
